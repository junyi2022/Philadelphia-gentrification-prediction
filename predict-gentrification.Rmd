---
title: "Philadelphia Census Block Group Gentrification Prediction Using Machine Learning"
author: "Junyi Yang, Ziyi Guo, Haoyu Zhu"
date: "May, 2024"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    code_folding: hide
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}

# You can set some global options for knitting chunks

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)

# Load some libraries

library(tidycensus)
library(tidyverse)
library(dplyr)
library(sf)
library(spdep)
library(caret)
library(ckanr)
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot) # plot correlation plot
library(corrr)      # another way to plot correlation plot
library(kableExtra)
library(jtools)     # for regression model plots
library(ggstance) # to support jtools plots
library(ggpubr)    # plotting R^2 value on ggplot point scatter
library(broom.mixed) # needed for effects plots
library(RColorBrewer)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(corrr)
library(classInt)
library(tmap)
library(stargazer)
library(RSocrata)
library(kableExtra)
library(caret)
library(knitr) 
library(pscl)
library(plotROC)
library(pROC)
library(lubridate)
library(stargazer)


# inflation rate for 2017 is *2.13%*, for 2018 is *2.44%*, for 2019 is *1.81%*, for 2020 is *1.23%*.  
inflationAdjust2016 <- 1.0126
inflationAdjust2017 <- 1.0213
inflationAdjust2018 <- 1.0244
inflationAdjust2019 <- 1.0181
inflationAdjust2020 <- 1.0123
inflationAdjust2021 <- 1.047

```

## Introduction

This project aims to use machine learning methods to forecast patterns of gentrification in the unit of census block groups within Philadelphia. Gentrification, a complex socioeconomic phenomenon, has significant implications for urban development, housing affordability, and community dynamics. From the research of the [Urban Displacement Project](https://www.urbandisplacement.org/about/what-are-gentrification-and-displacement/), gentrification is usually associated with real estate speculation, increased investment in neighborhood amenities such as transit and parks, change in land use, and changes in the character of the neighborhood such as business type change." These new investments often lead to displacement of existing low-income residents through rent increase, eviction, and other displacement pressure. Therefore, this project seeks to empower policymakers, urban planners, and community advocates to make informed decisions and implement equitable strategies for sustainable growth and inclusive development.   

This project will use the 2017 and 2018 data to train the machine learning model and use the 2018 and 2019 data to do the validation. There are two reasons for this decision. Firstly, the COVID pandemic in 2020 largely impacted the normal pattern of people's daily life, so we don't want our model to span across the year 2020. Secondly, the area of each census block group gets updated [every decade](https://learn.arcgis.com/en/related-concepts/united-states-census-geography.htm#:~:text=Census%20blocks%20are%20often%20the,)%20or%20centroids%20(points).), so we are not able to get the same census block group before and after 2020. The reason why we don't focus on the years after 2020 is because currently there are only 2 years of census data, which is not enough for training the model and testing on a different year.    

The census data used in this project is from [American Census Survey (ACS)](https://data.census.gov/) 5-year survey, and other data used in this project comes from [OpenDataPhilly](https://opendataphilly.org/).    


## Calculate Gentrification (Dependent Variable)

Since gentrification is a vague and variable term, we need to define gentrification in this project and calculate the area of gentrification within Philadelphia by using related geospatial datasets.  

Based on the [dictionary definition](https://www.merriam-webster.com/dictionary/gentrification), the term *gentrification* means "a process in which a poor area (as of a city) experiences an influx of middle-class or wealthy people who renovate and rebuild homes and businesses and which often results in an increase in property values and the displacement of earlier, usually poorer residents." In this way, there are two main characteristics of gentrification: census composition change and property value change.  

Firstly, for the census composition change, we define a census block group as gentrifying if its percentage of minority group (non-white) decreases by more than 4% in a 1-year interval and its median household income before is below Philadelphia County's median. In a research about ["Gentrification Definitions and Racial Change: Considering the Evidence,"](https://www.enterprisecommunity.org/resources/gentrification-definitions-and-racial-change-considering-evidence) it analyzes racial change compared to the status of gentrification. Extracting the information from this study and briefly simplifying the analysis, the gentrification area usually has a net loss of black people between 1.1 to 8.4 percent, so we will use the rough average of this scope, which is 4 percent. Besides, this research also points to an online [Gentrification Comparison Tool](https://www.enterprisecommunity.org/resources/gentrification-comparison-tool) that "takes 3 popular approaches to measure gentrification - by Freeman (2005), Ellen & O’Regan (2008), and McKinnish et al (2010)." From there, the census data change they focus on is *average household income*. The 3 approaches have slightly different standards to define gentrification based on average household income: median household income below metro area median, average household income below 70% of metro area median, or average household income in the bottom 20% among all evaluated tracts nationally. In order to fit our analysis of Philadelphia County, this project will use *median household income below metro area median*.  

Secondly, for the property value change, we define it as a more than 5% increase in a 1-year interval. Based on the research from Drexel University Urban Heath Collaborative's study of ["A Measure of Gentrification For Use in Longitudinal Public Health Studies in the US,"](https://drexel.edu/uhc/resources/briefs/Measure-of-Gentrification-for-Use-in-Longitudinal-Public-Health-Studies-in-the-US/) it used 50% - 75% increase in home value in a 10-year interval to define gentrification and more than 75% home value increase to define intense gentrification. Therefore, transferring this criterion to our 1-year interval will be a *more than 5% increase*.  

Since many of our criteria involves money, we need to adjust for inflation. Based on [Macrotrends](https://www.macrotrends.net/global-metrics/countries/USA/united-states/inflation-rate-cpi) data,  the inflation rate for 2017 is *2.13%* and for 2018 is *2.44%*.   

__In summary, our method to calculate gentrification is:__    
1. Percentage of minority group (non-white) decreases by more than 4% in a 1-year interval.  
2. Median household income 1 years ago was below Philadelphia County's median.
3. More than 5% increase of property value in a 1-year interval

### Census Data

The census data we need to collect for calculating gentrification is ACS 5-year data from 2017 to 2019, and the geography is census block groups in Philadelphia. The demographic data we need to collect or calculate are total population, percentage of non-white population, and median household income.    

```{r, include = FALSE}

census2016 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2016, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2017 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2017, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2018 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2018, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2019 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2019, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2020 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2020, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2021 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2021, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

```


Since one of our criteria needs to compare median income to Philadelphia County's value. We need to calculate the median difference between each block group and the larger geography (Philadelphia) for the selected three years. Because some of the block groups do not have median household income value data from the census survey, we will keep the household income difference for those as NA.   

```{r}

census2016 <- census2016 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2016$MedHhIncome), NA, census2016$MedHhIncome - median(na.omit(census2016$MedHhIncome))))

census2017 <- census2017 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2017$MedHhIncome), NA, census2017$MedHhIncome - median(na.omit(census2017$MedHhIncome))))

census2018 <- census2018 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2018$MedHhIncome), NA, census2018$MedHhIncome - median(na.omit(census2018$MedHhIncome))))

census2019 <- census2019 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2019$MedHhIncome), NA, census2019$MedHhIncome - median(na.omit(census2019$MedHhIncome))))

census2020 <- census2020 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2020$MedHhIncome), NA, census2020$MedHhIncome - median(na.omit(census2020$MedHhIncome))))

census2021 <- census2021 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2021$MedHhIncome), NA, census2021$MedHhIncome - median(na.omit(census2021$MedHhIncome))))


```

### Property Value Data

The property value data used in this project comes from OpenDataPhilly's [Philadelphia Properties and Assessment History](https://opendataphilly.org/datasets/philadelphia-properties-and-assessment-history/) dataset. Because this dataset does not have geometry, we need to join this to the [Philadelphia Water Department's parcel data](https://opendataphilly.org/datasets/pwd-stormwater-billing-parcels/), which is originally used to calculate parcel-based stormwater charges for PWD customers under the new parcel-based stormwater billing program.   

Since our analysis needs 2017 to 2019's data, we will first extract these three years' property data from the history dataset.   

```{r , include = FALSE}

AssessData <- 
  read.csv(file.path("https://opendata-downloads.s3.amazonaws.com/assessments.csv")) 

Assess2016 <- AssessData[AssessData$year == 2016, ]
Assess2017 <- AssessData[AssessData$year == 2017, ]
Assess2018 <- AssessData[AssessData$year == 2018, ]
Assess2019 <- AssessData[AssessData$year == 2019, ]
Assess2020 <- AssessData[AssessData$year == 2020, ]
Assess2021 <- AssessData[AssessData$year == 2021, ]


PWDparcel <- st_read("https://opendata.arcgis.com/datasets/84baed491de44f539889f2af178ad85c_0.geojson") %>%
  st_transform(crs = 2272)

# need to change the id from character to number
PWDparcel$BRT_ID <- as.numeric(PWDparcel$BRT_ID)

```

In order to match the properties with the parcels, we use certain IDs to join them, and those are `parcel_number` in the property dataset and `BRT_ID` in the PWD parcel dataset. After joining these two dataset together, we will calculate the median property value in each census block group and add that as a new column in the corresponding census dataframe. This process will repeat for 3 times since we need to manipulate 3 years' data.    


```{r fig.width=10}

# 2016

assess_pwd_join_2016 <- inner_join(PWDparcel, Assess2016, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2016 <- st_join(census2016, assess_pwd_join_2016, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2016 <- aggregate(joined_data_2016["market_value"], by = list(joined_data_2016$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2016)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2016 <- merge(census2016, median_property_value_2016, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)


# 2017

assess_pwd_join_2017 <- inner_join(PWDparcel, Assess2017, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2017 <- st_join(census2017, assess_pwd_join_2017, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2017 <- aggregate(joined_data_2017["market_value"], by = list(joined_data_2017$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2017)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2017 <- merge(census2017, median_property_value_2017, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)

# 2018

assess_pwd_join_2018 <- inner_join(PWDparcel, Assess2018, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2018 <- st_join(census2018, assess_pwd_join_2018, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2018 <- aggregate(joined_data_2018["market_value"], by = list(joined_data_2018$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2018)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2018 <- merge(census2018, median_property_value_2018, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)


# 2019

assess_pwd_join_2019 <- inner_join(PWDparcel, Assess2019, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2019 <- st_join(census2019, assess_pwd_join_2019, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2019 <- aggregate(joined_data_2019["market_value"], by = list(joined_data_2019$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2019)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2019 <- merge(census2019, median_property_value_2019, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)


# 2021

assess_pwd_join_2021 <- inner_join(PWDparcel, Assess2021, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2021 <- st_join(census2021, assess_pwd_join_2021, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2021 <- aggregate(joined_data_2021["market_value"], by = list(joined_data_2021$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2021)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2021 <- merge(census2021, median_property_value_2021, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)


# 2020

assess_pwd_join_2020 <- inner_join(PWDparcel, Assess2020, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2020 <- st_join(census2020, assess_pwd_join_2020, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2020 <- aggregate(joined_data_2020["market_value"], by = list(joined_data_2020$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2020)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2020 <- merge(census2020, median_property_value_2020, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)

```

### Calculate change

Because of standard for calculating gentrification involves change between two years, we need to transfer the 2017 data to the 2018 dataframe and the 2018 data to the 2019 dataframe. Firstly, we transfer the percentage of minority(non-white) group and calculate the percent change within 1 year.    

```{r}

# 2016 to 2017

census2016_pctNonwhite <- census2016 %>%
  select(GEOID, pctNonWhite) %>%
  st_drop_geometry() %>% 
  rename(pctNW_2016 = pctNonWhite)

census2017 <- merge(census2017, census2016_pctNonwhite, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(NW_change_pct = (pctNonWhite - pctNW_2016) / pctNW_2016)

# 2018 to 2019

census2018_pctNonwhite <- census2018 %>%
  select(GEOID, pctNonWhite) %>%
  st_drop_geometry() %>% 
  rename(pctNW_2018 = pctNonWhite)

census2019 <- merge(census2019, census2018_pctNonwhite, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(NW_change_pct = (pctNonWhite - pctNW_2018) / pctNW_2018)


# 2020 to 2021

census2020_pctNonwhite <- census2020 %>%
  select(GEOID, pctNonWhite) %>%
  st_drop_geometry() %>% 
  rename(pctNW_2020 = pctNonWhite)

census2021 <- merge(census2021, census2020_pctNonwhite, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(NW_change_pct = (pctNonWhite - pctNW_2020) / pctNW_2020)

# 2016 to 2018

census2018_2 <- merge(census2018, census2016_pctNonwhite, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(NW_change_pct = (pctNonWhite - pctNW_2016) / pctNW_2016)

```

Secondly, we transfer the median household income difference and categorize this value. If the median household income one year ago is greater than the Philadelphia median, the census block group will get a `1`, and if the median household income one year ago is less than the Philadelphia median, the census block group will get a `0`. Besides, since we originally have some NA household income value, we will keep this new categorized value in those census block groups as NA.  

```{r}

# 2016 to 2017

census2016_medianHHI <- census2016 %>%
  select(GEOID, MedHhIncomeDif) %>%
  st_drop_geometry() %>% 
  mutate(MedHhIBool_2016 = ifelse(is.na(census2018$MedHhIncomeDif), NA, ifelse(census2016$MedHhIncomeDif < 0, 1, 0))) %>%
  select(GEOID, MedHhIBool_2016)

census2017 <- merge(census2017, census2016_medianHHI, by.x = "GEOID", by.y = "GEOID", all.x = TRUE)

# 2018 to 2019

census2018_medianHHI <- census2018 %>%
  select(GEOID, MedHhIncomeDif) %>%
  st_drop_geometry() %>% 
  mutate(MedHhIBool_2018 = ifelse(is.na(census2018$MedHhIncomeDif), NA, ifelse(census2018$MedHhIncomeDif < 0, 1, 0))) %>%
  select(GEOID, MedHhIBool_2018)

census2019 <- merge(census2019, census2018_medianHHI, by.x = "GEOID", by.y = "GEOID", all.x = TRUE)


# 2020 to 2021

census2020_medianHHI <- census2020 %>%
  select(GEOID, MedHhIncomeDif) %>%
  st_drop_geometry() %>% 
  mutate(MedHhIBool_2020 = ifelse(is.na(census2020$MedHhIncomeDif), NA, ifelse(census2020$MedHhIncomeDif < 0, 1, 0))) %>%
  select(GEOID, MedHhIBool_2020)

census2021 <- merge(census2021, census2020_medianHHI, by.x = "GEOID", by.y = "GEOID", all.x = TRUE)

# 2016 to 2018

census2018_2 <- merge(census2018_2, census2016_medianHHI, by.x = "GEOID", by.y = "GEOID", all.x = TRUE)

```

We also need to calculate the median value change within 1 year. In this way, we need to add the property value of 2017 in the 2018 dataframe and the property value of 2018 in the 2019 dataframe in order to calculate the difference. In order to calculate the percent change of the median property value, we also need to adjust for inflation.   

```{r}

# 2016 to 2017

census2016_prop <- census2016 %>%
  select(GEOID, median_property_value) %>%
  st_drop_geometry() %>% 
  rename(median_pv_2016 = median_property_value)

census2017 <- merge(census2017, census2016_prop, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(PV_change_pct = (median_property_value - median_pv_2016 * inflationAdjust2016) / median_pv_2016 * inflationAdjust2016)

# 2018 to 2019

census2018_prop <- census2018 %>%
  select(GEOID, median_property_value) %>%
  st_drop_geometry() %>% 
  rename(median_pv_2018 = median_property_value)

census2019 <- merge(census2019, census2018_prop, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(PV_change_pct = (median_property_value - median_pv_2018 * inflationAdjust2018) / median_pv_2018 * inflationAdjust2018)


# 2020 to 2021

census2020_prop <- census2020 %>%
  select(GEOID, median_property_value) %>%
  st_drop_geometry() %>% 
  rename(median_pv_2020 = median_property_value)

census2021 <- merge(census2021, census2020_prop, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(PV_change_pct = (median_property_value - median_pv_2020 * inflationAdjust2020) / median_pv_2020 * inflationAdjust2020)

# 2016 to 2018

census2018_2 <- merge(census2018_2, census2016_prop, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(PV_change_pct = (median_property_value - median_pv_2016 * inflationAdjust2016 * inflationAdjust2017) / median_pv_2016 * inflationAdjust2016 * inflationAdjust2017)


```


### Combine and Visualize

After all the manipulations above, we will finally calculate whether a census block group is gentrifying. If a census block group's percentage of minority group (non-white) decreases by more than 4% in 1 year, median household income one year ago was below Philadelphia's median, and property value increased by more than 5%, it will be categorized as `1`, meaning that it is gentrifying. Otherwise, it will receive a value of `0`, meaning that it is not gentrifying.    

The two plots below show the result of gentrification in the year 2018 and 2019. We can see more census block groups are gentrifying as time goes by, and most of them located around Center City and University City.  


```{r fig.width=10}

census2017_Gentrification <- census2017 %>%
  select(GEOID, NW_change_pct, MedHhIBool_2016, PV_change_pct) %>%
  mutate(Gentrification = ifelse(NW_change_pct < -0.04 & MedHhIBool_2016 == 1 & PV_change_pct > 0.05, 1, 0))

census2019_Gentrification <- census2019 %>%
  select(GEOID, NW_change_pct, MedHhIBool_2018, PV_change_pct) %>%
  mutate(Gentrification = ifelse(NW_change_pct < -0.04 & MedHhIBool_2018 == 1 & PV_change_pct > 0.05, 1, 0))

census2021_Gentrification <- census2021 %>%
  select(GEOID, NW_change_pct, MedHhIBool_2020, PV_change_pct) %>%
  mutate(Gentrification = ifelse(NW_change_pct < -0.04 & MedHhIBool_2020 == 1 & PV_change_pct > 0.05, 1, 0))

census2018_2_Gentrification <- census2018_2 %>%
  select(GEOID, NW_change_pct, MedHhIBool_2016, PV_change_pct) %>%
  mutate(Gentrification = ifelse(NW_change_pct < -0.08 & MedHhIBool_2016 == 1 & PV_change_pct > 0.1, 1, 0))

plot2017Gen <- ggplot() +
  geom_sf(data = census2017_Gentrification, aes(fill=Gentrification), colour=NA) +
  theme_void()

plot2019Gen <- ggplot() +
  geom_sf(data = census2019_Gentrification, aes(fill=Gentrification), colour=NA) +
  theme_void()

plot2021Gen <- ggplot() +
  geom_sf(data = census2021_Gentrification, aes(fill=Gentrification), colour=NA) +
  theme_void()

plot2018_2Gen <- ggplot() +
  geom_sf(data = census2018_2_Gentrification, aes(fill=Gentrification), colour=NA) +
  theme_void()

grid.arrange(
  plot2017Gen, plot2019Gen, plot2018_2Gen,
  ncol = 3  
) 

```



## Data Wrangling (Independent Variables)

### Data Gathering

### Data Gathering
The model needs multiple spatial and non-spatial data as possible independent variable. The first step here is to collect and read those data. The list includes: (17,18)

3. restaurant/grocery stores nearby
11. housing year
12. metro station
1. safety-eviction  
2. redline 
canopy


## Demographic characteristics

1. Age (child, youth)
2. Race (White, Black)
3. age

```{r}

#2017
Demo2017 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E",  
                        # TOTALPOP
                        
                        "B01001_003E","B01001_004E","B01001_005E","B01001_006E","B01001_027E","B01001_028E","B01001_029E","B01001_030E",
                        # UNDER18
                        
                        "B01001_007E","B01001_008E","B01001_009E","B01001_010E","B01001_011E","B01001_031E","B01001_032E","B01001_033E","B01001_034E","B01001_035E",
                        # UNDER30
                        
                        "B02001_002E", "B02001_003E",
                        # White, Black
                        
                        "B11016_001E","B11016_002E",
                        #hh type, family hh
                        
                        "B15002_011E","B15002_028E",
                        #Education attainment, HIGH SCHOOL
                        
                        "B19013_001E",
                        #MEDIA HH INCOME
                        
                        "B25001_001E",
                        #HU
                        "B25002_002E","B25003_003E",
                        #Occupied, RENTER OCCUPIED
                        
                        "B25018_001E"
                        #MEDIAN NUMBER OF ROOMS
                        ), 
          year = 2017, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         NumberBlack=B02001_003E,
         TotalHH = B11016_001E,
         NumberFamilyHH = B11016_002E,
         MedHHIncome = B19013_001E,
         TotalHU=B25001_001E,
         NumberOccupied=B25002_002E,
         NumberRenter = B25003_003E,
         MedNumRooms = B25018_001E) %>%
  mutate(NumberChild=B01001_003E+B01001_004E+B01001_005E+B01001_006E+
           B01001_027E+B01001_028E+B01001_029E+B01001_030E,
         NumberYouth=B01001_007E+B01001_008E+B01001_009E+B01001_010E+B01001_011E+
           B01001_031E+B01001_032E+B01001_033E+B01001_034E+B01001_035E,
         NumberHSEducation = B15002_011E+B15002_028E )%>%
  mutate(pctWhite=NumberWhites / TotalPop,
         pctBlack = NumberBlack/TotalPop,
         pctChild = NumberChild/TotalPop,
         pctYouth = NumberYouth / TotalPop,
         pctFamilyHH= NumberFamilyHH / TotalHH,
         pctOccupied = NumberOccupied/TotalHU,
         pctRent = NumberRenter / NumberOccupied,
         pctHSEducation = NumberHSEducation / TotalPop)%>%
  select(-starts_with("B"),-NAME,-TotalPop,-NumberWhites,-NumberBlack,-TotalHH,-NumberFamilyHH,-TotalHU,
         -NumberOccupied,-NumberRenter,-NumberChild,-NumberYouth,-NumberHSEducation)


#2018
Demo2018 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E",  
                        # TOTALPOP
                        
                        "B01001_003E","B01001_004E","B01001_005E","B01001_006E","B01001_027E","B01001_028E","B01001_029E","B01001_030E",
                        # UNDER18
                        
                        "B01001_007E","B01001_008E","B01001_009E","B01001_010E","B01001_011E","B01001_031E","B01001_032E","B01001_033E","B01001_034E","B01001_035E",
                        # UNDER30
                        
                        "B02001_002E", "B02001_003E",
                        # White, Black
                        
                        "B11016_001E","B11016_002E",
                        #hh type, family hh
                        
                        "B15002_011E","B15002_028E",
                        #Education attainment, HIGH SCHOOL
                        
                        "B19013_001E",
                        #MEDIA HH INCOME
                        
                        "B25001_001E",
                        #HU
                        "B25002_002E","B25003_003E",
                        #Occupied, RENTER OCCUPIED
                        
                        "B25018_001E"
                        #MEDIAN NUMBER OF ROOMS
                        ), 
          year = 2018, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         NumberBlack=B02001_003E,
         TotalHH = B11016_001E,
         NumberFamilyHH = B11016_002E,
         MedHHIncome = B19013_001E,
         TotalHU=B25001_001E,
         NumberOccupied=B25002_002E,
         NumberRenter = B25003_003E,
         MedNumRooms = B25018_001E) %>%
  mutate(NumberChild=B01001_003E+B01001_004E+B01001_005E+B01001_006E+
           B01001_027E+B01001_028E+B01001_029E+B01001_030E,
         NumberYouth=B01001_007E+B01001_008E+B01001_009E+B01001_010E+B01001_011E+
           B01001_031E+B01001_032E+B01001_033E+B01001_034E+B01001_035E,
         NumberHSEducation = B15002_011E+B15002_028E )%>%
  mutate(pctWhite=NumberWhites / TotalPop,
         pctBlack = NumberBlack/TotalPop,
         pctChild = NumberChild/TotalPop,
         pctYouth = NumberYouth / TotalPop,
         pctFamilyHH= NumberFamilyHH / TotalHH,
         pctOccupied = NumberOccupied/TotalHU,
         pctRent = NumberRenter / NumberOccupied,
         pctHSEducation = NumberHSEducation / TotalPop)%>%
  select(-starts_with("B"),-NAME,-TotalPop,-NumberWhites,-NumberBlack,-TotalHH,-NumberFamilyHH,-TotalHU,
         -NumberOccupied,-NumberRenter,-NumberChild,-NumberYouth,-NumberHSEducation)

```

## Amenities

1. School (HIGH SCHOOL?)
2. Park

### High school

Education amenities is one of the independenct variable we considered. 

The school data comes from The School District of Philadelphia's [School Lists](https://www.philasd.org/performance/programsservices/open-data/school-information/#school_lists) dataset. 

```{r}
#2017
school2017<- st_read("data/independent/2017-2018 Master School List (20180611).xlsx")

#2018
school2018<- st_read("data/independent/2018-2019 Master School List (20190510).csv")

```

We need to change the csv data into geom data and select the information we need. 

```{r}

#2017
school2017<-school2017%>%
  select(School.Level, GPS.Location)%>%
  mutate(latitude = as.numeric(substring(GPS.Location, 1, regexpr(",", GPS.Location) - 1)),
         longitude = as.numeric(substring(GPS.Location, regexpr(",", GPS.Location) + 1)))%>%
  st_as_sf(., coords = c("longitude", "latitude"), crs = 4326)%>%
  st_transform(crs = 2272)
  
#2018
school2018<-school2018%>%
  select(School.Level, GPS.Location)%>%
  mutate(latitude = as.numeric(substring(GPS.Location, 1, regexpr(",", GPS.Location) - 1)),
         longitude = as.numeric(substring(GPS.Location, regexpr(",", GPS.Location) + 1)))%>%
  st_as_sf(., coords = c("longitude", "latitude"), crs = 4326)%>%
  st_transform(crs = 2272)

```


```{r}

#2017
block_buffer2017 <- st_buffer(Demo2017, dist = 1000)

#2018
block_buffer2018 <- st_buffer(Demo2018, dist = 1000)

```

```{r}

#2017
school_block2017 <- st_join(school2017, block_buffer2017) %>%
  group_by(GEOID) %>%
  summarise(school = n())%>%
  st_drop_geometry()

data2017<-Demo2017%>%
  left_join(.,school_block2017, by ="GEOID")%>%
  mutate(school = replace_na(school, 0))

#2018
school_block2018 <- st_join(school2018, block_buffer2018) %>%
  group_by(GEOID) %>%
  summarise(school = n())%>%
  st_drop_geometry()

data2018<-Demo2018%>%
  left_join(.,school_block2018, by ="GEOID")%>%
  mutate(school = replace_na(school, 0))

```

## Park

```{r}

park<- st_read("data/independent/PPR_Program_Sites.geojson")%>%
  st_transform(crs = 2272)

```

```{r}

#2017
park_block2017 <- st_join(park, block_buffer2017) %>%
  group_by(GEOID) %>%
  summarise(park = n())%>%
  st_drop_geometry()

data2017<-data2017%>%
  left_join(.,park_block2017, by ="GEOID")%>%
  mutate(park = replace_na(park, 0))

#2018
park_block2018 <- st_join(park, block_buffer2018) %>%
  group_by(GEOID) %>%
  summarise(park = n())%>%
  st_drop_geometry()

data2018<-data2018%>%
  left_join(.,park_block2018, by ="GEOID")%>%
  mutate(park = replace_na(park, 0))

```


### Safety

```{r}

#2017
crime2017<- st_read("data/independent/incidents_part1_part2_2017/incidents_part1_part2.shp")%>%
  st_transform(crs = 2272)%>%
  filter(grepl("Burglary", text_gener))

#2018
crime2018<- st_read("data/independent/incidents_part1_part2_2018/incidents_part1_part2.shp")%>%
  st_transform(crs = 2272)%>%
  filter(grepl("Burglary", text_gener))

```

```{r}

#2017
crime_block2017 <- st_join(crime2017, Demo2017) %>%
  group_by(GEOID) %>%
  summarise(Burglary = n())%>%
  st_drop_geometry()

data2017<-data2017%>%
  left_join(.,crime_block2017, by ="GEOID")%>%
  mutate(Burglary = replace_na(Burglary, 0))

#2018
crime_block2018 <- st_join(crime2018, Demo2018) %>%
  group_by(GEOID) %>%
  summarise(Burglary = n())%>%
  st_drop_geometry()

data2018<-data2018%>%
  left_join(.,crime_block2018, by ="GEOID")%>%
  mutate(Burglary = replace_na(Burglary, 0))


```

### Redlining

```{r}

Redline <- st_read("data/independent/redlining.geojson")%>%
  st_transform(crs = 2272)

```

```{r}

Redline_block <- st_join(Demo2017, Redline) %>%
  select(GEOID, holc_grade)%>%
  mutate(holc_number = case_when(
  holc_grade == "Commercial" ~ 0,
  holc_grade == "A" ~ 1,
  holc_grade == "B" ~ 2,
  holc_grade == "C" ~ 3,
  holc_grade == "D" ~ 4,
  TRUE ~ NA
))%>%
  group_by(GEOID) %>%
  summarise(holc_number = max(holc_number))%>%
  st_drop_geometry()%>%
  mutate(holc_grade = case_when(
  holc_number == 0 ~ "Commercial",
  holc_number == 1 ~ "A",
  holc_number == 2 ~ "B",
  holc_number == 3 ~ "C",
  holc_number == 4 ~ "D",
  TRUE ~ NA
))%>%
  select(-holc_number)

#2017
data2017<-data2017%>%
  left_join(.,Redline_block, by ="GEOID")
  
#2018
data2018<-data2018%>%
  left_join(.,Redline_block, by ="GEOID")

```


## Summarize and preview the variables

The table shows all the independent variables by categories.

```{r preview the data}

data2018_summary<- data2018%>%
  st_drop_geometry()%>%
  select(-GEOID)

stargazer(data2018_summary, type = "text", digits = 1, title = "Summary Statistics")

```

## Model development

methodology explanation

```{r}

data2018 <-data2018%>%
  left_join(.,
            census2019_Gentrification%>%
              st_drop_geometry()%>%
              select(GEOID,Gentrification), 
            by ="GEOID")%>%
  na.omit(Gentrification)

```


### Data splitting

```{r}

inTrain <- createDataPartition(data2018$Gentrification, p = .50,
                                  list = FALSE,
                                  times = 1)

Gentrification.training <- data2018[inTrain,] 
Gentrification.test <- data2018[-inTrain,]

```




### Analyzing associations

An overview of the association between gentrification and multiple
independent variables

```{r Correlation, fig.height=7, fig.width=10}



```

### Correlation matrix

```{r fig.height=10, fig.width=10}



```

### Multivariate Regression

Construct baseline model

```{r mutlivariate_regression}



```

## Model testing

cross validation

```{r }


```

over/under predict location 

### Mean Absolute Percentage Error

```{r }


```

### Cross validation

```{r}


```

### Result of model testing

## Validation

history data

```{r}


```

### Summary

why invest recommendation for implementation

### Appendix

data source, variable definition, model specification

#### Model specification

##### Basic model

```{r}

model1 <- glm(Gentrification ~ ., 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))
summary(model1)

```

```{r}

testProbs <- data.frame(Outcome = as.factor(Gentrification.test$Gentrification),
                        Probs = predict(model1, Gentrification.test, type= "response"))

```

```{r}

ggplot(testProbs, aes(d = as.numeric(Outcome), m = Probs)) +
  geom_roc(n.cuts = 50, labels = TRUE, colour = "#FF82AB") +
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') +
  labs(title = "ROC Curve")+theme_minimal()

```



#### References

“Definition of GENTRIFICATION.” In Merriam-Webster, April 29, 2024. https://www.merriam-webster.com/dictionary/gentrification.  

“Gentrification Comparison Tool | Enterprise Community Partners.” Accessed May 5, 2024. https://www.enterprisecommunity.org/resources/gentrification-comparison-tool.  

Methods Brief. “A Measure of Gentrification for Use in Longitudinal Public Health Studies in the US.” Drexel University Urban Health Collaborative, August 2019. https://drexel.edu/uhc/resources/briefs/Measure-of-Gentrification-for-Use-in-Longitudinal-Public-Health-Studies-in-the-US/.  

Rachel Bogardus Drew. “Gentrification Definitions and Racial Change: Considering the Evidence.” Enterprise Community Partners, May 1, 2020. https://www.enterprisecommunity.org/resources/gentrification-definitions-and-racial-change-considering-evidence.  

“What Are Gentrification and Displacement – Urban Displacement.” Accessed May 5, 2024. https://www.urbandisplacement.org/about/what-are-gentrification-and-displacement/.   
