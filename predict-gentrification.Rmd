---
title: "Philadelphia Census Block Group Gentrification Prediction Using Machine Learning"
author: "Junyi Yang, Ziyi Guo, Haoyu Zhu"
date: "May, 2024"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    code_folding: hide
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}

# You can set some global options for knitting chunks

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)

# Load some libraries

library(tidycensus)
library(tidyverse)
library(dplyr)
library(sf)
library(spdep)
library(caret)
library(ckanr)
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot) # plot correlation plot
library(corrr)      # another way to plot correlation plot
library(kableExtra)
library(jtools)     # for regression model plots
library(ggstance) # to support jtools plots
library(ggpubr)    # plotting R^2 value on ggplot point scatter
library(broom.mixed) # needed for effects plots
library(RColorBrewer)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(corrr)
library(classInt)
library(stargazer)
library(RSocrata)
library(kableExtra)
library(caret)
library(knitr) 
library(pscl)
library(plotROC)
library(pROC)
library(lubridate)
library(stargazer)

# Inflation adjust
inflationAdjust2017 <- 1.0213
inflationAdjust2018 <- 1.0244

# Color palette
palette2 <- c('#6683a9', '#BF4146')
palette5 <- c('#BF4146', '#E5A186', '#F1C8BB', '#B3CADB','#6683a9')

```

## Introduction

This project aims to use machine learning methods to forecast patterns of gentrification in the unit of census block groups within Philadelphia. Gentrification, a complex socioeconomic phenomenon, has significant implications for urban development, housing affordability, and community dynamics. From the research of the [Urban Displacement Project](https://www.urbandisplacement.org/about/what-are-gentrification-and-displacement/), gentrification is usually associated with real estate speculation, increased investment in neighborhood amenities such as transit and parks, change in land use, and changes in the character of the neighborhood such as business type change." These new investments often lead to displacement of existing low-income residents through rent increase, eviction, and other displacement pressure. Therefore, this project seeks to empower policymakers, urban planners, and community advocates to make informed decisions and implement equitable strategies for sustainable growth and inclusive development.   

This project will use the 2018 and 2019 data to train the machine learning model and use the 2017 and 2018 data to do the validation. There are two reasons for this decision. Firstly, the COVID pandemic in 2020 largely impacted the normal pattern of people's daily life, so we don't want our model to span across the year 2020. Secondly, the area of each census block group gets updated [every decade](https://learn.arcgis.com/en/related-concepts/united-states-census-geography.htm#:~:text=Census%20blocks%20are%20often%20the,&#41;%20or%20centroids%20&#40;points&#41;.), so we are not able to get the same census block group before and after 2020.     

The census data used in this project is from [American Census Survey (ACS)](https://data.census.gov/) 5-year survey, and other data used in this project comes from [OpenDataPhilly](https://opendataphilly.org/).    


## Calculate Gentrification (Dependent Variable)

Since gentrification is a vague and variable term, we need to first define gentrification in this project and calculate the area of gentrification within Philadelphia by using related geospatial datasets.  

Based on the [dictionary definition](https://www.merriam-webster.com/dictionary/gentrification), the term *gentrification* means "a process in which a poor area (as of a city) experiences an influx of middle-class or wealthy people who renovate and rebuild homes and businesses and which often results in an increase in property values and the displacement of earlier, usually poorer residents." In this way, there are two main characteristics of gentrification: census composition change and property value change.  

Firstly, for the census composition change, we define a census block group as gentrifying if its percentage of minority group (non-white) decreases by more than 4% in a 1-year interval and its median household income before is below Philadelphia County's median. In a research about ["Gentrification Definitions and Racial Change: Considering the Evidence,"](https://www.enterprisecommunity.org/resources/gentrification-definitions-and-racial-change-considering-evidence) it analyzes racial change compared to the status of gentrification. Extracting the information from this study and briefly simplifying the analysis, the gentrification area usually has a net loss of black people between 1.1 to 8.4 percent, so we will use the rough average of this scope, which is 4 percent. Besides, this research also points to an online [Gentrification Comparison Tool](https://www.enterprisecommunity.org/resources/gentrification-comparison-tool) that "takes 3 popular approaches to measure gentrification - by Freeman (2005), Ellen & Oâ€™Regan (2008), and McKinnish et al (2010)." From there, the census data change they focus on is *average household income*. The 3 approaches have slightly different standards to define gentrification based on average household income: median household income below metro area median, average household income below 70% of metro area median, or average household income in the bottom 20% among all evaluated tracts nationally. In order to fit our analysis of Philadelphia County, this project will use *median household income below metro area median*.  

Secondly, for the property value change, we define it as a more than 5% increase in a 1-year interval. Based on the research from Drexel University Urban Heath Collaborative's study of ["A Measure of Gentrification For Use in Longitudinal Public Health Studies in the US,"](https://drexel.edu/uhc/resources/briefs/Measure-of-Gentrification-for-Use-in-Longitudinal-Public-Health-Studies-in-the-US/) it used 50% - 75% increase in home value in a 10-year interval to define gentrification and more than 75% home value increase to define intense gentrification. Therefore, transferring this criterion to our 1-year interval will be a *more than 5% increase*.  

Since many of our criteria involves money, we need to adjust for inflation. Based on [Macrotrends](https://www.macrotrends.net/global-metrics/countries/USA/united-states/inflation-rate-cpi) data,  the inflation rate for 2017 is *2.13%* and for 2018 is *2.44%*.   

__In summary, our method to calculate gentrification is:__    
1. Percentage of minority group (non-white) decreases by more than 4% in a 1-year interval.  
2. Median household income 1 years ago was below Philadelphia County's median.  
3. More than 5% increase of property value in a 1-year interval

### Census Data

The census data we need to collect for calculating gentrification is ACS 5-year data from 2017 to 2019, and the geography is census block groups in Philadelphia. The demographic data we need to collect are `B01001_001E Total Population`, `B02001_002E Race`, and `B19013_001E Median Household Income in the past 12 Months`. In this way, we can calculate the percentage of non-white population.     

```{r, include = FALSE}

census2017 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2017, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2018 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2018, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2019 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2019, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

```

```{r, eval = FALSE}

census2017 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2017, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2018 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2018, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

census2019 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E", "B02001_002E", "B19013_001E"), 
          year = 2019, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         NumberWhites = B02001_002E,
         MedHhIncome = B19013_001E) %>%
  mutate(pctNonWhite = 1 - NumberWhites / TotalPop)%>%
  select(-NAME, -B01001_001M, -B02001_002M, -B19013_001M)

```

Since one of our criteria needs to compare median income to Philadelphia County's value. We need to calculate the median difference between each block group and the larger geography (Philadelphia) for the selected three years. Because some of the block groups do not have median household income value data from the census data, we will keep the household income difference for those as NA.   

```{r}

census2017 <- census2017 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2017$MedHhIncome), NA, census2017$MedHhIncome - median(na.omit(census2017$MedHhIncome))))

census2018 <- census2018 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2018$MedHhIncome), NA, census2018$MedHhIncome - median(na.omit(census2018$MedHhIncome))))

census2019 <- census2019 %>%
  mutate(MedHhIncomeDif = ifelse(is.na(census2019$MedHhIncome), NA, census2019$MedHhIncome - median(na.omit(census2019$MedHhIncome))))


```

### Property Value Data

The property value data used in this project comes from OpenDataPhilly's [Philadelphia Properties and Assessment History](https://opendataphilly.org/datasets/philadelphia-properties-and-assessment-history/) dataset. Because this dataset does not have geometry, we need to join this to the [Philadelphia Water Department's parcel data](https://opendataphilly.org/datasets/pwd-stormwater-billing-parcels/), which is originally used to calculate parcel-based stormwater charges for PWD customers under the new parcel-based stormwater billing program.   

Since our analysis needs 2017 to 2019's data, we will first extract these three years' property data from the history dataset.   

```{r , include = FALSE}

AssessData <- 
  read.csv(file.path("https://opendata-downloads.s3.amazonaws.com/assessments.csv")) 

Assess2017 <- AssessData[AssessData$year == 2017, ]
Assess2018 <- AssessData[AssessData$year == 2018, ]
Assess2019 <- AssessData[AssessData$year == 2019, ]


PWDparcel <- st_read("https://opendata.arcgis.com/datasets/84baed491de44f539889f2af178ad85c_0.geojson") %>%
  st_transform(crs = 2272)

# need to change the id from character to number
PWDparcel$BRT_ID <- as.numeric(PWDparcel$BRT_ID)

```

In order to match the properties with the parcels, we use certain IDs to join them, and those are `parcel_number` in the property dataset and `BRT_ID` in the PWD parcel dataset. After joining these two dataset together, we will calculate the median property value in each census block group and add that as a new column in the corresponding census dataframe. This process will repeat for 3 times since we need to manipulate 3 years' data.    


```{r}

# 2017

assess_pwd_join_2017 <- inner_join(PWDparcel, Assess2017, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2017 <- st_join(census2017, assess_pwd_join_2017, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2017 <- aggregate(joined_data_2017["market_value"], by = list(joined_data_2017$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2017)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2017 <- merge(census2017, median_property_value_2017, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)


# 2019

assess_pwd_join_2019 <- inner_join(PWDparcel, Assess2019, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2019 <- st_join(census2019, assess_pwd_join_2019, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2019 <- aggregate(joined_data_2019["market_value"], by = list(joined_data_2019$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2019)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2019 <- merge(census2019, median_property_value_2019, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)


# 2018

assess_pwd_join_2018 <- inner_join(PWDparcel, Assess2018, join_by(BRT_ID == parcel_number))

# Perform a spatial join between the census block groups and property value data
joined_data_2018 <- st_join(census2018, assess_pwd_join_2018, join = st_intersects)

# Aggregate median property value by census block group
median_property_value_2018 <- aggregate(joined_data_2018["market_value"], by = list(joined_data_2018$GEOID), FUN = median) %>%
  st_drop_geometry()

# Rename the aggregated column
names(median_property_value_2018)[2] <- "median_property_value"

# Merge the aggregated median property value back to the census block groups sf object
census2018 <- merge(census2018, median_property_value_2018, by.x = "GEOID", by.y = "Group.1", all.x = TRUE)

```

### Calculate change

Because the standard for calculating gentrification involves change between two years, we need to transfer the 2017 data to the 2018 dataframe and the 2018 data to the 2019 dataframe. Firstly, we transfer the percentage of minority(non-white) group and calculate the percent change within 1 year.    

```{r fig.height=6, fig.width=12}

# 2017 to 2018

census2017_pctNonwhite <- census2017 %>%
  select(GEOID, pctNonWhite) %>%
  st_drop_geometry() %>% 
  rename(pctNW_2017 = pctNonWhite)

census2018 <- merge(census2018, census2017_pctNonwhite, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(NW_change_pct = (pctNonWhite - pctNW_2017) / pctNW_2017)


# 2018 to 2019

census2018_pctNonwhite <- census2018 %>%
  select(GEOID, pctNonWhite) %>%
  st_drop_geometry() %>% 
  rename(pctNW_2018 = pctNonWhite)

census2019 <- merge(census2019, census2018_pctNonwhite, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(NW_change_pct = (pctNonWhite - pctNW_2018) / pctNW_2018)


# Plots

# Calculate quantiles for class breaks
breaks_quantiles <- classIntervals(census2018$NW_change_pct, n = 5, na.rm=TRUE, style = "quantile")

# Generate custom labels showing the range of each class
labels <- paste0(formatC(breaks_quantiles$brks[-length(breaks_quantiles$brks)], format = "f", digits = 2, big.mark = ","), 
                 " - ", 
                 formatC(breaks_quantiles$brks[-1], format = "f", digits = 2, big.mark = ","))

plot2018 <- ggplot() +
  geom_sf(data = census2018, aes(fill = cut(NW_change_pct, breaks = breaks_quantiles$brks, include.lowest = TRUE)), color = "white", linewidth = 0.01) +
  scale_fill_manual(values = palette5, na.value = "#e9e9e9",
                     name = "Change Percentage",
                     labels = labels) +  # Use custom range labels
  labs(title = "Philadelphia Percent Non-white Change by Block Group in 2018") +
  theme_void()


# Calculate quantiles for class breaks
breaks_quantiles <- classIntervals(census2019$NW_change_pct, n = 5, na.rm=TRUE, style = "quantile")

# Generate custom labels showing the range of each class
labels <- paste0(formatC(breaks_quantiles$brks[-length(breaks_quantiles$brks)], format = "f", digits = 2, big.mark = ","), 
                 " - ", 
                 formatC(breaks_quantiles$brks[-1], format = "f", digits = 2, big.mark = ","))

plot2019 <- ggplot() +
  geom_sf(data = census2019, aes(fill = cut(NW_change_pct, breaks = breaks_quantiles$brks, include.lowest = TRUE)), color = "white", linewidth = 0.01) +
  scale_fill_manual(values = palette5, na.value = "#e9e9e9",
                     name = "Change Percentage",
                     labels = labels) +  # Use custom range labels
  labs(title = "Philadelphia Percent Non-white Change by Block Group in 2019") +
  theme_void()

grid.arrange(
  plot2018, plot2019,
  ncol = 2 
) 

```

Secondly, we transfer the median household income difference and categorize this value. If the median household income one year ago is greater than the Philadelphia median, the census block group will get a `1`, and if the median household income one year ago is less than the Philadelphia median, the census block group will get a `0`. Besides, since we originally have some NA household income value, we will keep this new categorized value in those census block groups as NA.    

```{r fig.height=6, fig.width=12.5}

# 2017 to 2018

census2017_medianHHI <- census2017 %>%
  select(GEOID, MedHhIncomeDif) %>%
  st_drop_geometry() %>% 
  mutate(MedHhIBool_2017 = ifelse(is.na(census2017$MedHhIncomeDif), NA, ifelse(census2017$MedHhIncomeDif < 0, 1, 0))) %>%
  select(GEOID, MedHhIBool_2017)

census2018 <- merge(census2018, census2017_medianHHI, by.x = "GEOID", by.y = "GEOID", all.x = TRUE)

census2018$MedHhIBool_2017Factor <- factor(census2018$MedHhIBool_2017,
                                                   levels = c(0, 1),
                                                   labels = c("More than PHL Median", "Less than PHL Median"))

# 2018 to 2019

census2018_medianHHI <- census2018 %>%
  select(GEOID, MedHhIncomeDif) %>%
  st_drop_geometry() %>% 
  mutate(MedHhIBool_2018 = ifelse(is.na(census2018$MedHhIncomeDif), NA, ifelse(census2018$MedHhIncomeDif < 0, 1, 0))) %>%
  select(GEOID, MedHhIBool_2018)

census2019 <- merge(census2019, census2018_medianHHI, by.x = "GEOID", by.y = "GEOID", all.x = TRUE)

census2019$MedHhIBool_2018Factor <- factor(census2019$MedHhIBool_2018,
                                                   levels = c(0, 1),
                                                   labels = c("More than PHL Median", "Less than PHL Median"))


# Plots

plot2018 <- ggplot() +
  geom_sf(data = census2018, aes(fill=MedHhIBool_2017Factor), colour='white', linewidth = 0.01) +
  scale_fill_manual(values = palette2, na.value = "#e9e9e9",
                     name = "Household Income") +
  labs(title = "Philadelphia Household Income by Block Group in 2017") +
  theme_void() 

plot2019 <- ggplot() +
  geom_sf(data = census2019, aes(fill=MedHhIBool_2018Factor), colour='white', linewidth = 0.01) +
  scale_fill_manual(values = palette2, na.value = "#e9e9e9",
                     name = "Household Income") +
  labs(title = "Philadelphia Household Income by Block Group in 2018") +
  theme_void()

grid.arrange(
  plot2018, plot2019,
  ncol = 2 
) 

```

We also need to calculate the median value change within 1 year. In this way, we need to add the property value of 2017 in the 2018 dataframe and the property value of 2018 in the 2019 dataframe in order to calculate the difference. In order to calculate the percent change of the median property value, we also need to adjust for inflation.   

```{r fig.height=6, fig.width=12}

# 2017 to 2018

census2017_prop <- census2017 %>%
  select(GEOID, median_property_value) %>%
  st_drop_geometry() %>% 
  rename(median_pv_2017 = median_property_value)

census2018 <- merge(census2018, census2017_prop, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(PV_change_pct = (median_property_value - median_pv_2017 * inflationAdjust2017) / median_pv_2017 * inflationAdjust2017)


# 2018 to 2019

census2018_prop <- census2018 %>%
  select(GEOID, median_property_value) %>%
  st_drop_geometry() %>% 
  rename(median_pv_2018 = median_property_value)

census2019 <- merge(census2019, census2018_prop, by.x = "GEOID", by.y = "GEOID", all.x = TRUE) %>%
  mutate(PV_change_pct = (median_property_value - median_pv_2018 * inflationAdjust2018) / median_pv_2018 * inflationAdjust2018)


# Plots

# Calculate quantiles for class breaks
breaks_quantiles <- classIntervals(census2018$PV_change_pct, n = 5, na.rm=TRUE, style = "quantile")

# Generate custom labels showing the range of each class
labels <- paste0(formatC(breaks_quantiles$brks[-length(breaks_quantiles$brks)], format = "f", digits = 2, big.mark = ","), 
                 " - ", 
                 formatC(breaks_quantiles$brks[-1], format = "f", digits = 2, big.mark = ","))

plot2018 <- ggplot() +
  geom_sf(data = census2018, aes(fill = cut(PV_change_pct, breaks = breaks_quantiles$brks, include.lowest = TRUE)), color = "white", linewidth = 0.01) +
  scale_fill_manual(values = palette5, na.value = "#e9e9e9",
                     name = "Change Percentage",
                     labels = labels) +  # Use custom range labels
  labs(title = "Philadelphia Property Value Change by Block Group in 2018") +
  theme_void()


# Calculate quantiles for class breaks
breaks_quantiles <- classIntervals(census2019$PV_change_pct, n = 5, na.rm=TRUE, style = "quantile")

# Generate custom labels showing the range of each class
labels <- paste0(formatC(breaks_quantiles$brks[-length(breaks_quantiles$brks)], format = "f", digits = 2, big.mark = ","), 
                 " - ", 
                 formatC(breaks_quantiles$brks[-1], format = "f", digits = 2, big.mark = ","))

plot2019 <- ggplot() +
  geom_sf(data = census2019, aes(fill = cut(PV_change_pct, breaks = breaks_quantiles$brks, include.lowest = TRUE)), color = "white", linewidth = 0.01) +
  scale_fill_manual(values = palette5, na.value = "#e9e9e9",
                     name = "Change Percentage",
                     labels = labels) +  # Use custom range labels
  labs(title = "Philadelphia Property Value Change by Block Group in 2019") +
  theme_void()

grid.arrange(
  plot2018, plot2019,
  ncol = 2 
) 

```


### Combine and Visualize

After all the manipulations above, we will finally calculate whether a census block group is gentrifying. If a census block group's percentage of minority group (non-white) decreases by more than 4% in 1 year, median household income one year ago was below Philadelphia's median, and property value increased by more than 5%, it will be categorized as `1`, meaning that it is gentrifying. Otherwise, it will receive a value of `0`, meaning that it is not gentrifying.    

The two plots below show the result of gentrification in the year 2018 and 2019. We can see more census block groups are gentrifying as time goes by, and most of them located around Center City and University City.  


```{r fig.height=6, fig.width=12}

census2018_Gentrification <- census2018 %>%
  select(GEOID, NW_change_pct, MedHhIBool_2017, PV_change_pct) %>%
  mutate(Gentrification = ifelse(NW_change_pct < -0.04 & MedHhIBool_2017 == 1 & PV_change_pct > 0.05, 1, 0))

census2018_Gentrification$GentrificationFactor <- factor(census2018_Gentrification$Gentrification,
                                                   levels = c(0, 1),
                                                   labels = c("Non-gentrified", "Gentrified"))

census2019_Gentrification <- census2019 %>%
  select(GEOID, NW_change_pct, MedHhIBool_2018, PV_change_pct) %>%
  mutate(Gentrification = ifelse(NW_change_pct < -0.04 & MedHhIBool_2018 == 1 & PV_change_pct > 0.05, 1, 0))

census2019_Gentrification$GentrificationFactor <- factor(census2019_Gentrification$Gentrification,
                                                   levels = c(0, 1),
                                                   labels = c("Non-gentrified", "Gentrified"))


plot2018Gen <- ggplot() +
  geom_sf(data = census2018_Gentrification, aes(fill=GentrificationFactor), colour='white', linewidth = 0.01) +
  scale_fill_manual(values = palette2, na.value = "#e9e9e9",
                     name = "Gentrification") +
  labs(title = "Philadelphia Gentrification by Block Group in 2018") +
  theme_void() 

plot2019Gen <- ggplot() +
  geom_sf(data = census2019_Gentrification, aes(fill=GentrificationFactor), colour='white', linewidth = 0.01) +
  scale_fill_manual(values = palette2, na.value = "#e9e9e9",
                     name = "Gentrification") +
  labs(title = "Philadelphia Gentrification by Block Group in 2019") +
  theme_void()

grid.arrange(
  plot2018Gen, plot2019Gen,
  ncol = 2 
) 

```



## Data Wrangling (Independent Variables)

The model needs multiple spatial and non-spatial data as possible independent variable. The first step here is to collect and read those data. The list includes: (17,18)

__Demographic and Housing characteristics__
1. Age (youth)  
2. Geographical Mobility: different housing 1 years ago  
3. Family structure  
4. Bachelor Degree Attainment  
5. Occupied Rate/ Renter Rate  
6. Housing Structure  
7. Population Density  

__Amenities__
8. School  
9. Parks  
10. Metro Station  

__Safety__
11. Burglary  

__Redlining__
12. Redlining  

### Demographic and Housing characteristics

```{r, include = FALSE}

#2017
Demo2017 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E",  
                        # TOTALPOP
                        
                        "B01001_007E","B01001_008E","B01001_009E","B01001_010E","B01001_011E",
                        "B01001_031E","B01001_032E","B01001_033E","B01001_034E","B01001_035E",
                        # 18-30
                        
                        "B07201_001E","B07201_002E",
                        #Same house
                        
                        "B11016_001E","B11016_009E",
                        #hh type, non-family hh
                        
                        "B15002_015E","B15002_016E","B15002_017E","B15002_018E",
                        "B15002_032E","B15002_033E","B15002_034E","B15002_035E",
                        #Education attainment, Bachelor Degree
                        
                        "B25001_001E",
                        #HU
                        "B25002_002E","B25003_003E",
                        #Occupied, RENTER OCCUPIED
                        
                        "B25018_001E"
                        #MEDIAN NUMBER OF ROOMS
                        ), 
          year = 2017, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         TotalHH = B11016_001E,
         NumbernonFamilyHH = B11016_009E,
         TotalHU=B25001_001E,
         NumberOccupied=B25002_002E,
         NumberRenter = B25003_003E,
         MedNumRooms = B25018_001E) %>%
  mutate(NumberYouth=B01001_007E+B01001_008E+B01001_009E+B01001_010E+B01001_011E+
           B01001_031E+B01001_032E+B01001_033E+B01001_034E+B01001_035E,
         NumberBachelor = B15002_015E+B15002_016E+B15002_017E+B15002_018E+
                        B15002_032E+B15002_033E+B15002_034E+B15002_035E,
         area_m2 = (as.numeric(st_area(.))*0.0929))%>%
  mutate(pctYouth = NumberYouth / TotalPop,
         prcMove = 1-(B07201_002E/B07201_001E),
         pctnonFamilyHH= NumbernonFamilyHH / TotalHH,
         pctOccupied = NumberOccupied/TotalHU,
         pctRent = NumberRenter / NumberOccupied,
         pctBachelor = NumberBachelor / TotalPop,
         PopDensity=TotalPop/area_m2)%>%
  select(-starts_with("B"),-NAME,-TotalPop,-TotalHH,-NumbernonFamilyHH,-TotalHU,
         -NumberOccupied,-NumberRenter,-NumberYouth,-NumberBachelor,-area_m2)


#2018
Demo2018 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E",  
                        # TOTALPOP
                        
                        "B01001_007E","B01001_008E","B01001_009E","B01001_010E","B01001_011E",
                        "B01001_031E","B01001_032E","B01001_033E","B01001_034E","B01001_035E",
                        # 18-30
                        
                        "B07201_001E","B07201_002E",
                        #Same house
                        
                        "B11016_001E","B11016_009E",
                        #hh type, non-family hh
                        
                        "B15002_015E","B15002_016E","B15002_017E","B15002_018E",
                        "B15002_032E","B15002_033E","B15002_034E","B15002_035E",
                        #Education attainment, Bachelor Degree
                        
                        "B25001_001E",
                        #HU
                        "B25002_002E","B25003_003E",
                        #Occupied, RENTER OCCUPIED
                        
                        "B25018_001E"
                        #MEDIAN NUMBER OF ROOMS
                        ), 
          year = 2018, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         TotalHH = B11016_001E,
         NumbernonFamilyHH = B11016_009E,
         TotalHU=B25001_001E,
         NumberOccupied=B25002_002E,
         NumberRenter = B25003_003E,
         MedNumRooms = B25018_001E) %>%
  mutate(NumberYouth=B01001_007E+B01001_008E+B01001_009E+B01001_010E+B01001_011E+
           B01001_031E+B01001_032E+B01001_033E+B01001_034E+B01001_035E,
         NumberBachelor = B15002_015E+B15002_016E+B15002_017E+B15002_018E+
                        B15002_032E+B15002_033E+B15002_034E+B15002_035E,
         area_m2 = (as.numeric(st_area(.))*0.0929))%>%
  mutate(pctYouth = NumberYouth / TotalPop,
         prcMove = 1-(B07201_002E/B07201_001E),
         pctnonFamilyHH= NumbernonFamilyHH / TotalHH,
         pctOccupied = NumberOccupied/TotalHU,
         pctRent = NumberRenter / NumberOccupied,
         pctBachelor = NumberBachelor / TotalPop,
         PopDensity=TotalPop/area_m2)%>%
  select(-starts_with("B"),-NAME,-TotalPop,-TotalHH,-NumbernonFamilyHH,-TotalHU,
         -NumberOccupied,-NumberRenter,-NumberYouth,-NumberBachelor,-area_m2)

```

```{r, eval = FALSE}

#2017
Demo2017 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E",  
                        # TOTALPOP
                        
                        "B01001_007E","B01001_008E","B01001_009E","B01001_010E","B01001_011E",
                        "B01001_031E","B01001_032E","B01001_033E","B01001_034E","B01001_035E",
                        # 18-30
                        
                        "B07201_001E","B07201_002E",
                        #Same house
                        
                        "B11016_001E","B11016_009E",
                        #hh type, non-family hh
                        
                        "B15002_015E","B15002_016E","B15002_017E","B15002_018E",
                        "B15002_032E","B15002_033E","B15002_034E","B15002_035E",
                        #Education attainment, Bachelor Degree
                        
                        "B25001_001E",
                        #HU
                        "B25002_002E","B25003_003E",
                        #Occupied, RENTER OCCUPIED
                        
                        "B25018_001E"
                        #MEDIAN NUMBER OF ROOMS
                        ), 
          year = 2017, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         TotalHH = B11016_001E,
         NumbernonFamilyHH = B11016_009E,
         TotalHU=B25001_001E,
         NumberOccupied=B25002_002E,
         NumberRenter = B25003_003E,
         MedNumRooms = B25018_001E) %>%
  mutate(NumberYouth=B01001_007E+B01001_008E+B01001_009E+B01001_010E+B01001_011E+
           B01001_031E+B01001_032E+B01001_033E+B01001_034E+B01001_035E,
         NumberBachelor = B15002_015E+B15002_016E+B15002_017E+B15002_018E+
                        B15002_032E+B15002_033E+B15002_034E+B15002_035E,
         area_m2 = (as.numeric(st_area(.))*0.0929))%>%
  mutate(pctYouth = NumberYouth / TotalPop,
         prcMove = 1-(B07201_002E/B07201_001E),
         pctnonFamilyHH= NumbernonFamilyHH / TotalHH,
         pctOccupied = NumberOccupied/TotalHU,
         pctRent = NumberRenter / NumberOccupied,
         pctBachelor = NumberBachelor / TotalPop,
         PopDensity=TotalPop/area_m2)%>%
  select(-starts_with("B"),-NAME,-TotalPop,-TotalHH,-NumbernonFamilyHH,-TotalHU,
         -NumberOccupied,-NumberRenter,-NumberYouth,-NumberBachelor,-area_m2)


#2018
Demo2018 <- get_acs(geography = "block group", 
          survey = "acs5",
          variables = c("B01001_001E",  
                        # TOTALPOP
                        
                        "B01001_007E","B01001_008E","B01001_009E","B01001_010E","B01001_011E",
                        "B01001_031E","B01001_032E","B01001_033E","B01001_034E","B01001_035E",
                        # 18-30
                        
                        "B07201_001E","B07201_002E",
                        #Same house
                        
                        "B11016_001E","B11016_009E",
                        #hh type, non-family hh
                        
                        "B15002_015E","B15002_016E","B15002_017E","B15002_018E",
                        "B15002_032E","B15002_033E","B15002_034E","B15002_035E",
                        #Education attainment, Bachelor Degree
                        
                        "B25001_001E",
                        #HU
                        "B25002_002E","B25003_003E",
                        #Occupied, RENTER OCCUPIED
                        
                        "B25018_001E"
                        #MEDIAN NUMBER OF ROOMS
                        ), 
          year = 2018, 
          state = "42", 
          county = "101", 
          geometry = T, 
          output = "wide") %>%
  st_transform(crs = 2272) %>%
  rename(TotalPop = B01001_001E,
         TotalHH = B11016_001E,
         NumbernonFamilyHH = B11016_009E,
         TotalHU=B25001_001E,
         NumberOccupied=B25002_002E,
         NumberRenter = B25003_003E,
         MedNumRooms = B25018_001E) %>%
  mutate(NumberYouth=B01001_007E+B01001_008E+B01001_009E+B01001_010E+B01001_011E+
           B01001_031E+B01001_032E+B01001_033E+B01001_034E+B01001_035E,
         NumberBachelor = B15002_015E+B15002_016E+B15002_017E+B15002_018E+
                        B15002_032E+B15002_033E+B15002_034E+B15002_035E,
         area_m2 = (as.numeric(st_area(.))*0.0929))%>%
  mutate(pctYouth = NumberYouth / TotalPop,
         prcMove = 1-(B07201_002E/B07201_001E),
         pctnonFamilyHH= NumbernonFamilyHH / TotalHH,
         pctOccupied = NumberOccupied/TotalHU,
         pctRent = NumberRenter / NumberOccupied,
         pctBachelor = NumberBachelor / TotalPop,
         PopDensity=TotalPop/area_m2)%>%
  select(-starts_with("B"),-NAME,-TotalPop,-TotalHH,-NumbernonFamilyHH,-TotalHU,
         -NumberOccupied,-NumberRenter,-NumberYouth,-NumberBachelor,-area_m2)

```

### Amenities

#### School

Education amenities is one of the independent variable we considered.  

The school data comes from The School District of Philadelphia's [School Lists](https://www.philasd.org/performance/programsservices/open-data/school-information/#school_lists) dataset.  

```{r, include=FALSE}
#2017
school2017<- st_read("data/independent/2017-2018 Master School List (20180611).xlsx")

#2018
school2018<- st_read("data/independent/2018-2019 Master School List (20190510).csv")

```

We need to change the csv data into geom data and select the information we need.  

```{r}

#2017
school2017<-school2017%>%
  select(School.Level, GPS.Location)%>%
  mutate(latitude = as.numeric(substring(GPS.Location, 1, regexpr(",", GPS.Location) - 1)),
         longitude = as.numeric(substring(GPS.Location, regexpr(",", GPS.Location) + 1)))%>%
  st_as_sf(., coords = c("longitude", "latitude"), crs = 4326)%>%
  st_transform(crs = 2272)
  
#2018
school2018<-school2018%>%
  select(School.Level, GPS.Location)%>%
  mutate(latitude = as.numeric(substring(GPS.Location, 1, regexpr(",", GPS.Location) - 1)),
         longitude = as.numeric(substring(GPS.Location, regexpr(",", GPS.Location) + 1)))%>%
  st_as_sf(., coords = c("longitude", "latitude"), crs = 4326)%>%
  st_transform(crs = 2272)


#2017
school_block2017 <- st_join(school2017, Demo2017) %>%
  group_by(GEOID) %>%
  summarise(school = n()) %>%
  st_drop_geometry() 

#2018
school_block2018 <- st_join(school2018, Demo2018) %>%
  group_by(GEOID) %>%
  summarise(school = n())%>%
  st_drop_geometry() 

```


#### Park

The park data comes from OpenDataPhilly [Parks & Recreation Program Sites](https://opendataphilly.org/datasets/parks-recreation-program-sites) dataset.

```{r, include=FALSE}

park<- st_read("data/independent/PPR_Program_Sites.geojson")%>%
  st_transform(crs = 2272)

```

```{r}

#2017
park_block2017 <- st_join(park, 
                             st_buffer(Demo2017, dist = 500)) %>%
  group_by(GEOID) %>%
  summarise(park = n())%>%
  st_drop_geometry() 

#2018

park_block2018 <- st_join(park, 
                             st_buffer(Demo2017, dist = 500)) %>%
  group_by(GEOID) %>%
  summarise(park = n())%>%
  st_drop_geometry() 

```

#### Metro Station

The station data comes from STEPTA [Highspeed Stations](https://data-septa.opendata.arcgis.com/datasets/af52d74b872045d0abb4a6bbbb249453_0/explore) dataset.

```{r, include=FALSE}

station <- st_read("data/independent/Highspeed_Stations.geojson")%>%
  st_transform(crs=2272)

```

```{r}

#2017
station_block2017 <- st_join(station, 
                             Demo2017) %>%
  group_by(GEOID) %>%
  summarise(station = n())%>%
  st_drop_geometry() 

#2018
station_block2018 <- st_join(station, 
                             Demo2018) %>%
  group_by(GEOID) %>%
  summarise(station = n())%>%
  st_drop_geometry() 

```

### Safety

The crime data comes from Opendataphilly [Crime Incidents](https://opendataphilly.org/datasets/crime-incidents/) dataset.

```{r, include=FALSE}

#2017
crime2017<- st_read("data/independent/incidents_part1_part2_2017/incidents_part1_part2.shp")%>%
  st_transform(crs = 2272)%>%
  filter(grepl("Burglary", text_gener))

#2018
crime2018<- st_read("data/independent/incidents_part1_part2_2018/incidents_part1_part2.shp")%>%
  st_transform(crs = 2272)%>%
  filter(grepl("Burglary", text_gener))

```

```{r}

#2017
crime_block2017 <- st_join(crime2017, Demo2017) %>%
  group_by(GEOID) %>%
  summarise(Burglary = n())%>%
  st_drop_geometry()

#2018
crime_block2018 <- st_join(crime2018, Demo2018) %>%
  group_by(GEOID) %>%
  summarise(Burglary = n())%>%
  st_drop_geometry()

```

### Redlining

The historic Redlining data comes from [Philadelphia Office of the Controller](https://controller.phila.gov/philadelphia-audits/mapping-the-legacy-of-structural-racism-in-philadelphia/) .

```{r, include=FALSE}

Redline <- st_read("data/independent/redlining.geojson")%>%
  st_transform(crs = 2272)

```

```{r}

Redline_block <- st_join(Demo2017, Redline) %>%
  select(GEOID, holc_grade)%>%
  mutate(holc_number = case_when(
  holc_grade == "Commercial" ~ 0,
  holc_grade == "A" ~ 1,
  holc_grade == "B" ~ 2,
  holc_grade == "C" ~ 3,
  holc_grade == "D" ~ 4,
  TRUE ~ NA
))%>%
  group_by(GEOID) %>%
  summarise(holc_number = max(holc_number))%>%
  st_drop_geometry()%>%
  mutate(holc_grade = case_when(
  holc_number == 0 ~ "Commercial",
  holc_number == 1 ~ "A",
  holc_number == 2 ~ "B",
  holc_number == 3 ~ "C",
  holc_number == 4 ~ "D",
  TRUE ~ NA
))%>%
  select(-holc_number)

```


## Summarize and preview the variables

The table shows all the independent variables by categories.

```{r}

#2017
data2017<-Demo2017%>%
  left_join(.,school_block2017, by ="GEOID")%>% 
  left_join(.,park_block2017, by ="GEOID")%>%  
  left_join(.,station_block2017, by ="GEOID")%>% 
  left_join(.,crime_block2017, by ="GEOID")%>% 
  left_join(.,Redline_block, by ="GEOID")
  
#2018
data2018<-Demo2018%>%
  left_join(.,school_block2018, by ="GEOID")%>%  
  left_join(.,park_block2018, by ="GEOID")%>% 
  left_join(.,station_block2018, by ="GEOID")%>%  
  left_join(.,crime_block2018, by ="GEOID")%>% 
  left_join(.,Redline_block, by ="GEOID")
  

#2017

data2017 <- data2017%>%
  mutate(school = replace_na(school, 0)) %>%
  mutate(school.factor= case_when(  school == 0 ~ "0",  school == 1 ~ "1",  school == 2 ~ "2",  school > 2 ~"over 2"))%>%
  mutate(park = replace_na(park, 0)) %>%
  mutate(park.factor= case_when(  park == 0 ~ "0",  park == 1 ~ "1",  park == 2 ~ "2",  park > 2 ~"over 2")) %>%
  mutate(station = replace_na(station, 0) )%>%
  mutate(station.factor= case_when(  station == 0 ~ "0",  station == 1 ~ "1",  station > 1 ~"over 1")) %>%
  mutate(Burglary = replace_na(Burglary, 0) )


#2018
data2018 <- data2018%>%
  mutate(school = replace_na(school, 0)) %>%
  mutate(school.factor= case_when(  school == 0 ~ "0",  school == 1 ~ "1",  school == 2 ~ "2",  school > 2 ~"over 2"))%>%
  mutate(park = replace_na(park, 0)) %>%
  mutate(park.factor= case_when(  park == 0 ~ "0",  park == 1 ~ "1",  park == 2 ~ "2",  park > 2 ~"over 2")) %>%
  mutate(station = replace_na(station, 0) )%>%
  mutate(station.factor= case_when(  station == 0 ~ "0",  station == 1 ~ "1",  station > 1 ~"over 1")) %>%
  mutate(Burglary = replace_na(Burglary, 0) )


data2018_summary<- data2018 %>%
  st_drop_geometry() %>%
  select(-GEOID, -holc_grade, -school.factor, -park.factor, -station.factor) 

# stargazer(data2018_summary, type = "text", digits = 1, title = "Summary Statistics")

summary_data <- round(do.call(cbind, lapply(data2018_summary, summary)), digits = 2)

as.data.frame(t(summary_data)) %>%
  select(-"NA's") %>%
  rename('Minimum' = 'Min.',
         '1st Quantile' = '1st Qu.',
         '3rd Quantile' = '3rd Qu.',
         'Maximun' = 'Max.') %>%
  kable(caption = "Summary of Quantitative Independent Variables") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))%>%
  footnote(general_title = "\n", general = "Table 1")

```



## Model development

methodology explanation

```{r}

data2018 <-data2018%>%
  left_join(.,
            census2019_Gentrification%>%
              st_drop_geometry()%>%
              select(GEOID,Gentrification), 
            by ="GEOID")%>%
  na.omit(Gentrification)

```

### Data splitting

```{r}

inTrain <- createDataPartition(data2018$Gentrification, p = .50,
                                  list = FALSE,
                                  times = 1)

Gentrification.training <- data2018[inTrain,] 
Gentrification.test <- data2018[-inTrain,]

```

### Analyzing associations

using our finalized model 6, specific model selection could refer to appendix.

```{r, include = FALSE}

model <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

fit_metrics <- pR2(model)

```

```{r, eval = FALSE}

model <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

fit_metrics <- pR2(model)

```

```{r}

as.data.frame(t(fit_metrics)) %>%
  kable(caption = "Fit Metrics for Logistic Regression Model", digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))%>%
  footnote(general_title = "\n", general = "Table 2")

```


### Optimize Threshold

```{r}

options(yardstick.event_first = FALSE)

testProbs <- data.frame(Outcome = as.factor(Gentrification.test$Gentrification),
                        Probs = predict(model, Gentrification.test, type= "response"))

testProbs <- 
  testProbs %>% 
  mutate(
         predClass_30 = as.factor(ifelse(testProbs$Probs > 0.3 , 1, 0)),
         predClass_20 = as.factor(ifelse(testProbs$Probs > 0.2 , 1, 0)),
         predClass_15 = as.factor(ifelse(testProbs$Probs > 0.15 , 1, 0)),
         predClass_10 = as.factor(ifelse(testProbs$Probs > 0.1 , 1, 0)),
         predClass_05 = as.factor(ifelse(testProbs$Probs > 0.05 , 1, 0))) 

testProbs %>%
  dplyr::select(-Probs) %>%
  gather(Variable, Value, -Outcome) %>%
  group_by(Variable) %>%
  summarize(Specificity = round(yardstick::sens_vec(Outcome,factor(Value)),2),
            Sensitivity = round(yardstick::spec_vec(Outcome,factor(Value)),2),
            Accuracy = round(yardstick::accuracy_vec(Outcome,factor(Value)),2)) %>%
  kable(caption = "Optimize Threshold") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))%>%
  footnote(general_title = "\n", general = "Table 3")

```


### Confusion matrix

use the optimized thershold 0.1

```{r}

testProbs <- data.frame(Outcome = as.factor(Gentrification.test$Gentrification),
                        Probs = predict(model, Gentrification.test, type= "response"))


testProbs <- 
  testProbs %>%
  mutate(predOutcome  = as.factor(ifelse(testProbs$Probs > 0.1 , 1, 0)))


cm <- caret::confusionMatrix(testProbs$predOutcome, testProbs$Outcome, 
                       positive = "1")

mosaicplot(cm$table, color=palette2, main = "Mosaic Plot for Confusion Matrix",
           xlab = "Prediction", ylab = "Reference")

cm_df <- as.data.frame(round(cm$byClass, digit = 3)) %>% 
  head(5) %>%
  t()

rownames(cm_df) <- NULL

cm_df %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 4")

```

### Cross validation

```{r, include = FALSE}

data2018$Gentrification <- as.factor(data2018$Gentrification)

levels(data2018$Gentrification) <- make.names(levels(data2018$Gentrification))


ctrl <- trainControl(
  method = "cv",
  number = 100,
  classProbs = TRUE, 
  summaryFunction = twoClassSummary
)

cvFit <- train(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

cvFit

```

```{r, eval = FALSE}

data2018$Gentrification <- as.factor(data2018$Gentrification)

levels(data2018$Gentrification) <- make.names(levels(data2018$Gentrification))


ctrl <- trainControl(
  method = "cv",
  number = 100,
  classProbs = TRUE, 
  summaryFunction = twoClassSummary
)

cvFit <- train(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

cvFit

```

```{r}

cvFit_df <- as.data.frame(cvFit$results)[, 2:7]
cvFit_df %>% 
  kable(col.name=c('ROC', 'Sensitivity', 'Specificity', 'ROC SD', 'Sensitivity SD', 'Specificity SD'),caption = "Cross Validation", digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 5")

```


### Make Predictions

```{r}

testProbs <- data.frame(Outcome = as.factor(Gentrification.test$Gentrification),
                        Probs = predict(model, Gentrification.test, type= "response"))


ggplot(testProbs, aes(x = Probs, fill = as.factor(Outcome))) + 
  geom_density() +
  facet_grid(Outcome ~ .) +
  scale_fill_manual(values = palette2) +
  labs(x = "Probabilities", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome",
             subtitle = "No gentrification = 0, Gentrification = 1") +
  theme_minimal() +
  theme(legend.position = "none") 

```

### ROC Curve

```{r}

ggplot(testProbs, aes(d = as.numeric(Outcome), m = Probs)) +
  geom_roc(n.cuts = 50, labels = FALSE, colour = "#BF4146") +
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1, color = '#6683a9') +
  labs(title = "ROC Curve") +
  theme_minimal()

```




#### Confusion Matrix

We employ a threshold of 0.05 to optimize the sensitivity. We want a better sensitivity. A good sensitivity means that our model could correctly identify  True Positive, the gentrification block groups. Effective sensitivity empowers governments to implement targeted interventions in these areas, mitigating or reducing future gentrification.

```{r}

testProbs <- 
  testProbs %>%
  mutate(predOutcome  = as.factor(ifelse(testProbs$Probs > 0.1 , 1, 0)))


cm <- caret::confusionMatrix(testProbs$predOutcome, testProbs$Outcome, 
                       positive = "1")

cm_df <- as.data.frame(round(cm$byClass, digit = 3)) %>% 
  head(5) %>%
  t()

rownames(cm_df) <- NULL

cm_df %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 6")
```

## Validation

Validate using the 2017 Data
and compared with the 2018 model results

```{r 2017 data}

data2017 <-data2017%>%
  left_join(.,
            census2018_Gentrification%>%
              st_drop_geometry()%>%
              select(GEOID,Gentrification), 
            by ="GEOID")%>%
  na.omit(Gentrification)

data2017$Gentrification <- as.factor(data2017$Gentrification)

levels(data2017$Gentrification) <- make.names(levels(data2017$Gentrification))

validationProbs <- data.frame(
  Outcome = as.factor(data2017$Gentrification),
  Probs = predict(model, data2017, type = "response")
)

validationProbs <- 
  validationProbs %>%
  mutate(predOutcome  = as.factor(ifelse(validationProbs$Probs > 0.1 , 1, 0)))

validationProbs <- validationProbs %>%
  mutate(Outcome = as.numeric(gsub("X", "", Outcome)))
validationProbs$predOutcome <- as.numeric(as.character(validationProbs$predOutcome))

# Convert to factors ensuring both have the same levels
levels <- union(levels(factor(validationProbs$Outcome)), levels(factor(validationProbs$predOutcome)))

validationProbs$Outcome <- factor(validationProbs$Outcome, levels = levels)
validationProbs$predOutcome <- factor(validationProbs$predOutcome, levels = levels)

```

### 2017 Cross Validation

```{r 2017 cv, include=FALSE}
cvFit <- train(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade,
  data = data2017 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

cvFit
```

```{r, eval=FALSE}
cvFit <- train(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade,
  data = data2017 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

cvFit
```

```{r}

cvFit_df <- as.data.frame(cvFit$results)[, 2:7]
cvFit_df %>% 
  kable(col.name=c('ROC', 'Sensitivity', 'Specificity', 'ROC SD', 'Sensitivity SD', 'Specificity SD'),caption = "Cross Validation", digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 7")

```

### 2017 Confusion Matrix

```{r 2017 Confusion Matrix}

# Now, run the confusion matrix
confusionMatrix <- caret::confusionMatrix(validationProbs$predOutcome, validationProbs$Outcome, positive = "1")

confusionMatrix_df <- as.data.frame(round(confusionMatrix$byClass, digit = 3)) %>% 
  head(5) %>%
  t()

rownames(confusionMatrix_df) <- NULL

confusionMatrix_df %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 8")

```
```{r}

ggplot(testProbs, aes(x = Probs, fill = as.factor(Outcome))) + 
  geom_density() +
  facet_grid(Outcome ~ .) +
  scale_fill_manual(values = palette2) +
  labs(x = "Probabilities", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome",
             subtitle = "No gentrification = 0, Gentrification = 1") +
  theme_minimal() +
  theme(legend.position = "none") 

```

### 2017 ROC Curve

```{r}

ggplot(validationProbs, aes(d = as.numeric(Outcome), m = Probs)) +
  geom_roc(n.cuts = 50, labels = FALSE, colour = "#BF4146") +
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1, color = '#6683a9') +
  labs(title = "ROC Curve") +
  theme_minimal()

```



## Summary

why invest recommendation for implementation

## Appendix

data source, variable definition, model specification

### Model specification

```{r fig.height=8, fig.width=8}

numericVars <- data2018 %>%
  st_drop_geometry() %>%  
  select_if(is.numeric) %>% 
  na.omit() 

correlation_matrix <- cor(numericVars)


numericVars %>% 
  correlate() %>% 
  autoplot() +
  geom_tile(aes(fill = r), color = "#e9e9e9") +
  geom_text(aes(label = round(r,digits=2)), size = 3) +
  scale_fill_gradient2(low = "#6683a9", mid = "white", high = "#BF4146",  # Specify color gradient
                       midpoint = 0, limits = c(-1, 1),
                       breaks = seq(-1, 1, by = 0.2)) +
  labs(title = "Correlation across numeric variables")  # Set plot title

```


### Basic model

```{r, include=FALSE}

model1 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity,
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model2 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+log(PopDensity), 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model3 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model4 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model5 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model6 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model7 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model8 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park.factor+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))


modelList <- paste0("model", 1:8)
bar <- map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("model",1:8)) %>%
  gather(model,McFadden) 

```

```{r, eval=FALSE}

model1 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity,
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model2 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+log(PopDensity), 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model3 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model4 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model5 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model6 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model7 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))

model8 <- glm(Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park.factor+station.factor+Burglary+holc_grade, 
             data = as.data.frame(Gentrification.training) %>% 
                     dplyr::select(-GEOID, -geometry),
                  family="binomial" (link="logit"))


modelList <- paste0("model", 1:8)
bar <- map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("model",1:8)) %>%
  gather(model,McFadden) 

```

```{r}

bar %>%
  ggplot(aes(model, McFadden)) +
    geom_bar(stat="identity", fill="#BF4146") +
    labs(title= "McFadden R-Squared by Model") +
    theme_minimal()

```


### AIC

```{r}

aic_values <- c(AIC(model1), AIC(model2), AIC(model3), AIC(model4), AIC(model5), AIC(model6), AIC(model7), AIC(model8))

# Create a data frame to store model numbers and corresponding AIC values
model_comparison <- data.frame(Model = c("Model 1", "Model 2", "Model 3", "Model 4","Model 5", "Model 6", "Model 7", "Model 8"),
                                AIC = aic_values) %>%
                                t()

colnames(model_comparison) <- as.character(model_comparison[1, ])  # Set column names to values in the first row
model_comparison <- model_comparison[-1, , drop = FALSE]  # Remove the first row

# Create a table using kable
kable(model_comparison, caption = "Comparison of AIC values") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 9")

```



### Cross validation

```{r, include=FALSE}

data2018$Gentrification <- as.factor(data2018$Gentrification)

levels(data2018$Gentrification) <- make.names(levels(data2018$Gentrification))


ctrl <- trainControl(
  method = "cv",
  number = 100,
  classProbs = TRUE, 
  summaryFunction = twoClassSummary
)

#model5
cvFit5 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

#model6
cvFit6 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

#model7
cvFit7 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

#model8
cvFit8 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park.factor+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

```

```{r, eval=FALSE}

data2018$Gentrification <- as.factor(data2018$Gentrification)

levels(data2018$Gentrification) <- make.names(levels(data2018$Gentrification))


ctrl <- trainControl(
  method = "cv",
  number = 100,
  classProbs = TRUE, 
  summaryFunction = twoClassSummary
)

#model5
cvFit5 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

#model6
cvFit6 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school+park+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

#model7
cvFit7 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

#model8
cvFit8 <- train(
  Gentrification ~ MedNumRooms+pctYouth+pctnonFamilyHH+prcMove+pctOccupied+pctRent+pctBachelor+PopDensity+
                school.factor+park.factor+station.factor+Burglary+holc_grade,
  data = data2018 %>%
    dplyr::select(-GEOID, -geometry),
  method = "glm",
  family = "binomial",
  metric = "ROC",
  trControl = ctrl
)

```

```{r}

cvFit_df5 <- as.data.frame(cvFit5$results)[, 2:7]
cvFit_df6 <- as.data.frame(cvFit6$results)[, 2:7]
cvFit_df7 <- as.data.frame(cvFit7$results)[, 2:7]
cvFit_df8 <- as.data.frame(cvFit8$results)[, 2:7]

cvFit_combine <- rbind(cvFit_df5, cvFit_df6, cvFit_df7, cvFit_df8)
row.names(cvFit_combine) <- c("Model 5", "Model 6", "Model 7", "Model 8")

cvFit_combine %>% 
  kable(col.name=c('ROC', 'Sensitivity', 'Specificity', 'ROC SD', 'Sensitivity SD', 'Specificity SD'),caption = "Cross Validation", digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))  %>%
  footnote(general_title = "\n", general = "Table 10")


```

choose model6 as our best model


## References

â€œDefinition of GENTRIFICATION.â€ In Merriam-Webster, April 29, 2024. https://www.merriam-webster.com/dictionary/gentrification.  

â€œGentrification Comparison Tool | Enterprise Community Partners.â€ Accessed May 5, 2024. https://www.enterprisecommunity.org/resources/gentrification-comparison-tool.  

Methods Brief. â€œA Measure of Gentrification for Use in Longitudinal Public Health Studies in the US.â€ Drexel University Urban Health Collaborative, August 2019. https://drexel.edu/uhc/resources/briefs/Measure-of-Gentrification-for-Use-in-Longitudinal-Public-Health-Studies-in-the-US/.  

Rachel Bogardus Drew. â€œGentrification Definitions and Racial Change: Considering the Evidence.â€ Enterprise Community Partners, May 1, 2020. https://www.enterprisecommunity.org/resources/gentrification-definitions-and-racial-change-considering-evidence.  

â€œWhat Are Gentrification and Displacement â€“ Urban Displacement.â€ Accessed May 5, 2024. https://www.urbandisplacement.org/about/what-are-gentrification-and-displacement/.   
